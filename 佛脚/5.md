# EventLoop
#### 进程与线程区别？JS 单线程带来的好处？
本质上来说，两个名词都是 CPU 工作时间片的一个描述

进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。

单线程的好处：JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。

#### 什么是执行栈？
是一个存储函数调用的栈结构，遵循先进后出的原则。

当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题

#### 异步代码执行顺序？解释一下什么是 Event Loop ？
当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。

不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。

Eventloop执行顺序

1、首先执行同步代码，这属于宏任务

2、当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行

3、执行所有微任务

4、当执行完所有微任务后，如有必要会渲染页面

5、然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数

这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。

#### Node 中的 Event Loop 和浏览器中的有什么区别？process.nexttick 执行顺序？
Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。

##### 1、timer
timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。

同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。

##### 2、I/O
I/O 阶段会处理一些上一轮循环中的少数未执行的 I/O 回调

##### 3、idle, prepare
idle, prepare 阶段内部实现

##### 4、poll
poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情

回到 timer 阶段执行回调

执行 I/O 回调

并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情

如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制

如果 poll 队列为空时，会有两件事发生

如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调

如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去

当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。

##### 5、check
check 阶段执行 setImmediate
##### 6、close callbacks
close callbacks 阶段执行 close 事件
